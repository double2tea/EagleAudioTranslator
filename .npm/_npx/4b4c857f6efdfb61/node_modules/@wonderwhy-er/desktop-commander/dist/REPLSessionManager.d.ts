interface TerminalManager {
    executeCommand: (command: string, options?: any) => Promise<any>;
    sendInputToProcess: (pid: number, input: string) => boolean;
    getNewOutput: (pid: number) => string;
    terminateProcess: (pid: number) => Promise<boolean>;
}
interface SSHOptions {
    username?: string;
    port?: number;
    identity?: string;
    password?: string;
    timeout?: number;
}
interface ExecuteOptions {
    timeout?: number;
    stopOnError?: boolean;
}
export declare class REPLSessionManager {
    private sessions;
    private terminalManager;
    private defaultPromptPatterns;
    constructor(terminalManager: TerminalManager);
    /**
     * Create a new SSH session
     * @param host - SSH host to connect to
     * @param options - SSH connection options
     * @returns PID of the created SSH session
     */
    createSSHSession(host: string, options?: SSHOptions): Promise<number>;
    /**
     * Create a new REPL session for a specific language
     * @param language - Language for the REPL (python, node, bash)
     * @param options - Configuration options
     * @returns PID of the created session
     */
    createSession(language: string, options?: any): Promise<number>;
    /**
     * Execute code in an existing REPL session
     * @param pid - Process ID of the REPL session
     * @param code - Code to execute
     * @param options - Execution options
     * @returns Results including output and status
     */
    executeCode(pid: number, code: string, options?: ExecuteOptions): Promise<any>;
    /**
     * Send input to a REPL process and wait for output with timeout
     * @param pid - Process ID
     * @param input - Input to send
     * @param language - REPL language
     * @param timeoutMs - Timeout in milliseconds
     * @returns Result object with output and status
     */
    sendAndReadREPL(pid: number, input: string, language: string, timeoutMs?: number): Promise<any>;
    /**
     * Handle multi-line code input for different languages
     * @param pid - Process ID
     * @param code - Multi-line code
     * @param language - REPL language
     * @param timeout - Timeout in milliseconds
     * @returns Result object
     */
    handleMultilineCode(pid: number, code: string, language: string, timeout: number): Promise<any>;
    /**
     * Detect if the REPL output is complete and ready for next input
     * @param output - Current output
     * @param language - REPL language or session type
     * @returns Whether output is complete
     */
    isOutputComplete(output: string, language: string): boolean;
    /**
     * Calculate appropriate timeout based on code complexity
     * @param code - Code to analyze
     * @returns Timeout in milliseconds
     */
    calculateTimeout(code: string): number;
    /**
     * Detect errors in REPL output
     * @param output - REPL output
     * @param language - REPL language
     * @returns Detected error or null
     */
    detectErrors(output: string, language: string): string | null;
    /**
     * Clean and format REPL output
     * @param output - Raw output
     * @param input - Input that was sent
     * @param language - REPL language
     * @returns Cleaned output
     */
    cleanOutput(output: string, input: string, language: string): string;
    /**
     * List all active REPL sessions
     * @returns List of session objects
     */
    listSessions(): Array<any>;
    /**
     * Close a specific REPL session
     * @param pid - Process ID to close
     * @returns Success status
     */
    closeSession(pid: number): Promise<boolean>;
    /**
     * Close all idle sessions older than specified time
     * @param maxIdleMs - Maximum idle time in milliseconds
     * @returns Number of closed sessions
     */
    closeIdleSessions(maxIdleMs?: number): Promise<number>;
}
export {};
