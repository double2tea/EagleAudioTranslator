import { expect } from 'chai';
import { describe, it, beforeEach, afterEach } from 'mocha';
import * as sinon from 'sinon';
import { initializeREPLManager, replCommandHandler } from './replCommandHandler';
describe('REPL Command Handler', () => {
    let mockSessionManager;
    let sandbox;
    beforeEach(() => {
        // Create a sinon sandbox for test isolation
        sandbox = sinon.createSandbox();
        // Create mock for REPLSessionManager
        mockSessionManager = {
            createSession: sandbox.stub().resolves(12345),
            executeCode: sandbox.stub().resolves({
                success: true,
                output: 'test output'
            }),
            createSSHSession: sandbox.stub().resolves(54321),
            sendAndReadREPL: sandbox.stub().resolves({
                success: true,
                output: 'ssh output'
            }),
            listSessions: sandbox.stub().returns([
                { pid: 12345, language: 'node' },
                { pid: 54321, language: 'ssh' }
            ]),
            closeSession: sandbox.stub().resolves(true),
            closeIdleSessions: sandbox.stub().resolves(2)
        };
        // Create a mock terminal manager
        const mockTerminalManager = {};
        // Use a more direct approach to set up the testing environment
        // Override the module's private replManager variable with our mock
        global.replManager = mockSessionManager;
        initializeREPLManager(mockTerminalManager);
    });
    afterEach(() => {
        // Restore all stubbed methods
        sandbox.restore();
        // Reset the module state
        global.replManager = null;
    });
    it('should create a REPL session', async () => {
        const result = await replCommandHandler.createREPLSession({
            language: 'node'
        });
        expect(result.success).to.be.true;
        expect(result.pid).to.equal(12345);
    });
    it('should execute code in a REPL session', async () => {
        const result = await replCommandHandler.executeREPLCode({
            pid: 12345,
            code: 'console.log("test")'
        });
        expect(result.success).to.be.true;
        expect(result.output).to.equal('test output');
    });
    it('should create an SSH session', async () => {
        const result = await replCommandHandler.createSSHSession({
            host: 'example.com',
            username: 'user'
        });
        expect(result.success).to.be.true;
        expect(result.pid).to.equal(54321);
    });
    it('should execute a command in an SSH session', async () => {
        const result = await replCommandHandler.executeSSHCommand({
            pid: 54321,
            command: 'ls -la'
        });
        expect(result.success).to.be.true;
        expect(result.output).to.equal('ssh output');
    });
    it('should list all REPL sessions', () => {
        const result = replCommandHandler.listREPLSessions();
        expect(result.success).to.be.true;
        expect(result.sessions).to.have.length(2);
        expect(result.sessions[0].pid).to.equal(12345);
        expect(result.sessions[1].pid).to.equal(54321);
    });
    it('should close a REPL session', async () => {
        const result = await replCommandHandler.closeREPLSession({
            pid: 12345
        });
        expect(result.success).to.be.true;
    });
    it('should close idle REPL sessions', async () => {
        const result = await replCommandHandler.closeIdleREPLSessions({
            maxIdleMs: 3600000 // 1 hour
        });
        expect(result.success).to.be.true;
        expect(result.closedCount).to.equal(2);
    });
    it('should handle errors when REPL manager is not initialized', async () => {
        // Reset the handler to simulate uninitialized state
        initializeREPLManager(null);
        const result = await replCommandHandler.createREPLSession({
            language: 'node'
        });
        expect(result.success).to.be.false;
        expect(result.error).to.equal('REPL Manager not initialized');
    });
});
